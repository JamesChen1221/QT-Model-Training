# 特徵工程實戰指南

## 🎯 目標

當你的資料量達到 100+ 筆時，如何有效地增加特徵來提升模型準確度。

---

## 📊 當前專案狀態

### 現有特徵（40 個）

**基本特徵（12 個）**：
1. 產業
2. 5日高價距離 (%)
3. 5日低價距離 (%)
4. 1個月高價距離 (%)
5. 1個月低價距離 (%)
6. 6個月高價距離 (%)
7. 6個月低價距離 (%)
8. 盤前 (%)
9. 觸發類型
10. 消息情緒分數
11. EPS Surprise (%)
12. Revenue Surprise (%)
13. 展望 (Guidance)

**趨勢特徵（15 個）**：
- 120天趨勢斜率（5 個）
- 20天趨勢斜率（5 個）
- 5天趨勢斜率（5 個）

**產業特徵（13 個）**：
- 產業 One-Hot 編碼

---

## 🚀 階段性特徵擴展計劃

### 階段 1: 資料量 100-200 筆

**目標**：謹慎增加 5-10 個高質量特徵

#### 建議新增特徵

**1. 成交量特徵（3 個）**
```python
# 成交量相關
'盤前成交量比率',           # 盤前成交量 / 平均成交量
'5日成交量變化率',          # 近5日成交量變化
'成交量突破指標',           # 是否突破平均成交量
```

**理由**：
- 成交量是重要的市場指標
- 與價格變化高度相關
- 容易取得且穩定

**2. 波動率特徵（2 個）**
```python
# 價格波動
'5日波動率',               # 近5日價格標準差
'20日波動率',              # 近20日價格標準差
```

**理由**：
- 波動率影響當沖潛力
- 高波動 = 高風險高報酬

**3. 相對強度特徵（2 個）**
```python
# 相對表現
'相對大盤強度',            # 股價變化 / 大盤變化
'相對產業強度',            # 股價變化 / 產業平均變化
```

**理由**：
- 相對強度比絕對價格更重要
- 反映股票的相對吸引力

**實作範例**：
```python
def add_stage1_features(data):
    """階段1: 增加基礎特徵"""
    
    # 1. 成交量特徵
    data['盤前成交量比率'] = data['盤前成交量'] / data['平均成交量']
    data['5日成交量變化率'] = (data['當日成交量'] - data['5日平均成交量']) / data['5日平均成交量']
    data['成交量突破指標'] = (data['當日成交量'] > data['20日平均成交量'] * 1.5).astype(int)
    
    # 2. 波動率特徵
    data['5日波動率'] = data['5日收盤價序列'].apply(lambda x: np.std(x))
    data['20日波動率'] = data['20日收盤價序列'].apply(lambda x: np.std(x))
    
    # 3. 相對強度特徵
    data['相對大盤強度'] = data['盤前 (%)'] / data['大盤盤前 (%)']
    data['相對產業強度'] = data['盤前 (%)'] / data['產業平均盤前 (%)']
    
    return data
```

### 階段 2: 資料量 200-500 筆

**目標**：增加 10-15 個進階特徵

#### 建議新增特徵

**1. 技術指標（5 個）**
```python
# 經典技術指標
'RSI_14',                  # 相對強弱指數
'MACD',                    # MACD 指標
'MACD_signal',             # MACD 信號線
'BB_position',             # 布林通道位置 (0-1)
'ATR_14',                  # 平均真實範圍
```

**2. 價格型態（3 個）**
```python
# 價格型態識別
'是否突破新高',            # 是否創近期新高
'是否跌破新低',            # 是否創近期新低
'價格位置',                # 在近期高低點之間的位置 (0-1)
```

**3. 時間特徵（3 個）**
```python
# 時間相關
'是否財報季',              # Q1/Q2/Q3/Q4 財報月
'距離上次財報天數',        # 距離上次財報的天數
'月份',                    # 1-12 月
```

**4. 交互特徵（4 個）**
```python
# 特徵交互
'盤前×消息情緒',           # 盤前漲幅 × 消息情緒分數
'EPS×展望',                # EPS驚喜 × 展望
'波動率×成交量',           # 波動率 × 成交量比率
'產業×觸發類型',           # 產業 × 觸發類型
```

**實作範例**：
```python
def add_stage2_features(data):
    """階段2: 增加進階特徵"""
    
    # 1. 技術指標
    data['RSI_14'] = data['收盤價序列'].apply(calculate_rsi, period=14)
    data['MACD'], data['MACD_signal'] = calculate_macd(data['收盤價序列'])
    data['BB_position'] = calculate_bb_position(data['收盤價序列'])
    data['ATR_14'] = data['價格序列'].apply(calculate_atr, period=14)
    
    # 2. 價格型態
    data['是否突破新高'] = (data['當前價'] >= data['20日最高價']).astype(int)
    data['是否跌破新低'] = (data['當前價'] <= data['20日最低價']).astype(int)
    data['價格位置'] = (data['當前價'] - data['20日最低價']) / (data['20日最高價'] - data['20日最低價'])
    
    # 3. 時間特徵
    data['是否財報季'] = data['月份'].isin([1, 4, 7, 10]).astype(int)
    data['距離上次財報天數'] = (data['當前日期'] - data['上次財報日期']).dt.days
    data['月份'] = data['開盤日期'].dt.month
    
    # 4. 交互特徵
    data['盤前×消息情緒'] = data['盤前 (%)'] * data['消息情緒分數']
    data['EPS×展望'] = data['EPS Surprise (%)'] * data['展望 (Guidance)']
    data['波動率×成交量'] = data['5日波動率'] * data['盤前成交量比率']
    data['產業×觸發類型'] = data['產業'] * data['觸發類型']
    
    return data
```

### 階段 3: 資料量 500+ 筆

**目標**：可以使用更複雜的特徵工程

#### 建議新增特徵

**1. 多項式特徵**
```python
from sklearn.preprocessing import PolynomialFeatures

# 選擇重要特徵進行多項式擴展
important_features = ['盤前 (%)', '消息情緒分數', 'EPS Surprise (%)']
poly = PolynomialFeatures(degree=2, include_bias=False)
X_poly = poly.fit_transform(data[important_features])
```

**2. 聚類特徵**
```python
from sklearn.cluster import KMeans

# 根據歷史表現分群
kmeans = KMeans(n_clusters=5, random_state=42)
data['股票群組'] = kmeans.fit_predict(data[['盤前 (%)', '波動率', '成交量比率']])
```

**3. 目標編碼（Target Encoding）**
```python
# 產業的平均表現
industry_mean = data.groupby('產業')['#開盤 (%)'].mean()
data['產業平均表現'] = data['產業'].map(industry_mean)
```

---

## 🔍 特徵選擇方法

### 方法 1: 特徵重要性過濾

```python
def select_features_by_importance(model, X, y, feature_names, threshold=0.01):
    """根據特徵重要性選擇特徵"""
    
    # 訓練模型
    model.fit(X, y)
    
    # 獲取特徵重要性
    importance = pd.DataFrame({
        '特徵': feature_names,
        '重要性': model.feature_importances_
    }).sort_values('重要性', ascending=False)
    
    # 過濾
    selected = importance[importance['重要性'] > threshold]['特徵'].tolist()
    
    print(f"原始特徵數: {len(feature_names)}")
    print(f"選擇特徵數: {len(selected)}")
    print(f"\n前10重要特徵:")
    print(importance.head(10))
    
    return selected
```

### 方法 2: 遞迴特徵消除（RFE）

```python
from sklearn.feature_selection import RFE

def select_features_by_rfe(model, X, y, n_features=20):
    """使用 RFE 選擇特徵"""
    
    selector = RFE(model, n_features_to_select=n_features, step=1)
    selector.fit(X, y)
    
    selected_features = [feature_names[i] for i, selected in enumerate(selector.support_) if selected]
    
    print(f"選擇的 {n_features} 個特徵:")
    for i, feat in enumerate(selected_features, 1):
        print(f"  {i}. {feat}")
    
    return selected_features
```

### 方法 3: 相關性分析

```python
def remove_correlated_features(data, threshold=0.9):
    """移除高度相關的特徵"""
    
    # 計算相關矩陣
    corr_matrix = data.corr().abs()
    
    # 找出高度相關的特徵對
    upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    
    # 移除相關性 > threshold 的特徵
    to_drop = [column for column in upper.columns if any(upper[column] > threshold)]
    
    print(f"移除 {len(to_drop)} 個高度相關的特徵:")
    for feat in to_drop:
        print(f"  - {feat}")
    
    return data.drop(columns=to_drop)
```

---

## 📈 特徵評估流程

### 完整評估流程

```python
def evaluate_new_features(X_old, X_new, y, model, cv=5):
    """評估新特徵的效果"""
    
    from sklearn.model_selection import cross_val_score
    
    # 評估舊特徵
    scores_old = cross_val_score(model, X_old, y, cv=cv, scoring='r2')
    
    # 評估新特徵
    scores_new = cross_val_score(model, X_new, y, cv=cv, scoring='r2')
    
    # 比較
    print("=" * 60)
    print("特徵評估結果")
    print("=" * 60)
    print(f"\n舊特徵 ({X_old.shape[1]} 個):")
    print(f"  平均 R²: {scores_old.mean():.4f} (+/- {scores_old.std():.4f})")
    
    print(f"\n新特徵 ({X_new.shape[1]} 個):")
    print(f"  平均 R²: {scores_new.mean():.4f} (+/- {scores_new.std():.4f})")
    
    improvement = scores_new.mean() - scores_old.mean()
    print(f"\n改進: {improvement:+.4f}")
    
    if improvement > 0:
        print("✅ 新特徵有幫助！")
    else:
        print("❌ 新特徵沒有幫助，建議不要使用")
    
    return scores_old.mean(), scores_new.mean()
```

---

## ⚠️ 注意事項

### 1. 避免資料洩漏（Data Leakage）

**錯誤範例**：
```python
# ❌ 使用未來資訊
data['未來5日漲幅'] = ...  # 這是目標變數的一部分！

# ❌ 使用全部資料計算統計量
data['標準化價格'] = (data['價格'] - data['價格'].mean()) / data['價格'].std()
# 測試集的標準化用到了測試集的資訊！
```

**正確範例**：
```python
# ✅ 只使用歷史資訊
data['過去5日漲幅'] = ...  # OK

# ✅ 只用訓練集計算統計量
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)  # 只用訓練集 fit
X_test_scaled = scaler.transform(X_test)        # 測試集只 transform
```

### 2. 特徵縮放

```python
from sklearn.preprocessing import StandardScaler

# 對數值特徵進行標準化
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
```

### 3. 處理缺失值

```python
# 新特徵可能產生缺失值
data['新特徵'].fillna(data['新特徵'].median(), inplace=True)
```

---

## 🎯 實戰檢查清單

### 增加新特徵前

- [ ] 資料量是否充足？（> 20 × 當前特徵數）
- [ ] 新特徵是否有業務邏輯支持？
- [ ] 新特徵是否容易取得？
- [ ] 新特徵是否穩定可靠？

### 增加新特徵後

- [ ] 檢查是否有資料洩漏
- [ ] 檢查是否有缺失值
- [ ] 檢查特徵分布是否合理
- [ ] 使用交叉驗證評估效果
- [ ] 比較訓練集和測試集表現
- [ ] 檢查特徵重要性

### 特徵選擇

- [ ] 移除重要性 < 閾值的特徵
- [ ] 移除高度相關的特徵（相關性 > 0.9）
- [ ] 保留業務上重要的特徵
- [ ] 最終特徵數 < 資料量 / 20

---

## 📚 總結

### 關鍵原則

1. **資料量優先**：先確保資料量充足
2. **質量重於數量**：10 個好特徵 > 100 個差特徵
3. **逐步增加**：每次增加 5-10 個，驗證效果
4. **持續評估**：使用交叉驗證評估
5. **特徵選擇**：移除無用特徵

### 你的專案路線圖

```
當前（31 筆）:
  → 不增加特徵，專注收集資料

達到 100 筆:
  → 增加階段1特徵（5-10 個）
  → 成交量、波動率、相對強度

達到 200 筆:
  → 增加階段2特徵（10-15 個）
  → 技術指標、價格型態、交互特徵

達到 500 筆:
  → 增加階段3特徵
  → 多項式、聚類、目標編碼
```

---

**記住**：特徵工程是迭代過程，需要不斷實驗和驗證！
